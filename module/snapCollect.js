const t=function(t){const e=Object.create({identifier:this.identifier});return t.forEach(t=>{e[t[this.identifier].toString()]=t}),e},e=function(t){return Object.keys(t)},n={entries:function(){return Object.entries(this)},keys:function(){return Object.keys(this)},values:function(){return Object.values(this)},where:function(t){let e=Object.values(this);return Object.keys(t).forEach(n=>{e=e.filter(e=>JSON.stringify(e[n])==JSON.stringify(t[n]))}),e},combination:function(n){Array.isArray(n)&&(n=t.call(this,n));const r=e(n);return function(t,e){const n=[...t,...e],r=new Set(n);return Array.from(r)}(this.keys(),r).map(t=>{const e=this.get(t.toString()),r=n[t];return e||r})},intersection:function(n){Array.isArray(n)&&(n=t.call(this,n));const r=e(n);return function(t,e){let n={};return t.forEach(t=>n[t]=1),e.filter(t=>{if(1===n[t])return delete n[t],t})}(this.keys(),r).map(t=>this.get(t.toString()))}},r=function(t){if(!Boolean(t))throw"snapCollect: identifier must evaluate to true";const e=function(t){return{add:function(){const e=Array.from(arguments);e.forEach(e=>this.set(e[t],e))},clear:function(){const t=Object.keys(this);for(let e of t)delete this[e.toString()]},delete:function(t){delete this[t.toString()]},get:function(t){return this[t.toString()]},has:function(t){return Object.prototype.hasOwnProperty.call(this,t.toString())},get length(){return Object.keys(this).length},set:function(t,e){this[t.toString()]=e},toggle:function(e){const n=e[t];this.has(n)?this.delete(n):this.set(n,e)}}}(t);return Object.assign(e,n),e.identifier=t,e.name="SnapCollect",e};export default function(t){const e=r(t);return Object.create(e)}
//# sourceMappingURL=snapCollect.js.map
