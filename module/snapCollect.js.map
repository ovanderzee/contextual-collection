{"version":3,"file":"snapCollect.js","sources":["../src/functions.js","../src/core.js","../node_modules/my-lib/module/myLib.js","../src/yielding.js","../src/index.js","../src/maintenance.js"],"sourcesContent":["const keying = {\n    /**\n     * Check value applicable as key\n     * @private\n     * @param {Any} value\n     * @return {Boolean} useablity\n     */\n    test: function (value) {\n        return value && value.toString\n    },\n\n    /**\n     * Compose a key\n     * @private\n     * @param {Any} value - to convert\n     * @return {String} useable key\n     */\n    make: function (value) {\n        return value.toString()\n    },\n}\n\n/**\n * Convert an array to a likewise initialised SnapCollect object\n * @private\n * @this {SnapCollect}\n * @param {Object[]} foreignArray - to convert\n * @return {Object} keyed object\n */\nconst arrayToSnapCollect = function (foreignArray) {\n    const foreignCollection = Object.create(Object.getPrototypeOf(this))\n    foreignCollection.add(...foreignArray)\n    return foreignCollection\n}\n\n/**\n * Get identifier from initialised SnapCollect object,\n * @private\n * @param {SnapCollect} collection - initialised SnapCollect object\n * @return {String} identifier\n */\nconst getIdentifier = function (collection) {\n    return Object.getPrototypeOf(collection).identifier\n}\n\n/**\n * Act on data satisfing all conditions,\n * using a JSON.stringify comparison.\n * @private\n * @param {Object} conditions - one or more conditions\n * @param {Boolean} isAction - act on true or act on false\n */\nconst conditionalDeleting = function (conditions, isAction) {\n    const conditionsEntries = Object.entries(conditions)\n    const values = Object.values(this)\n    const identifier = getIdentifier(this)\n    for (let value of values) {\n        let satisfing = true\n        conditionsEntries.forEach((condition) => {\n            satisfing =\n                satisfing &&\n                JSON.stringify(value[condition[0]]) ===\n                    JSON.stringify(condition[1])\n        })\n        if (satisfing === isAction) this.delete(value[identifier])\n    }\n}\n\nexport { keying, arrayToSnapCollect, conditionalDeleting }\n","import { keying } from './functions'\n\nconst methods = {\n    // core functions\n\n    /**\n     * Delete the data kept with a key, and the key itself.\n     * @param {String} key\n     */\n    delete: function (key) {\n        if (!keying.test(key)) return\n        delete this[keying.make(key)]\n    },\n    /**\n     * Get the data kept with a key.\n     * @param {String} key\n     * @return {Object} the data\n     */\n    get: function (key) {\n        if (!keying.test(key)) return\n        return this[keying.make(key)]\n    },\n    /**\n     * Examine the existance of a key.\n     * @param {String} key\n     * @return {Boolean}\n     */\n    has: function (key) {\n        if (!keying.test(key)) return\n        return Object.prototype.hasOwnProperty.call(this, keying.make(key))\n    },\n    /**\n     * Count the number of records kept.\n     * @return {Number}\n     */\n    get length() {\n        return Object.keys(this).length\n    },\n    /**\n     * Place (or replace) a record under a certain key.\n     * @param {String} key\n     * @param {Object} data\n     */\n    set: function (key, data) {\n        if (!keying.test(key)) return\n        this[keying.make(key)] = data\n    },\n}\n\nexport { methods }\n","const e=function(){let e=Boolean(arguments.length);return Array.from(arguments).forEach(t=>{e=e&&\"number\"==typeof t&&Number.isFinite(t)}),e},t=e=>Boolean(e&&\"string\"==typeof e&&1===e.length),n=e=>t(e)&&Boolean(e.match(/[0-9]/)),o=e=>t(e)&&e.toLowerCase()!==e.toUpperCase(),r=e=>t(e)&&e===e.toLowerCase()&&e!==e.toUpperCase(),f=e=>t(e)&&e===e.toUpperCase()&&e!==e.toLowerCase(),i=e=>e&&e.split&&!e.split(\"\").some(e=>!(o(e)||n(e))),l=(e,t)=>{const n=e.match(t);return n&&n[0]===e},u=function(e,t){return e<\"1e-\"+t&&e>\"-1e-\"+t?0:Number(Math.round(e+\"e\"+t)+\"e-\"+t)},c=function(e,t){const n=function(e,t){if(isNaN(e)||!Number.isInteger(t)||t<1)return\"NaN\";const n=Math.abs(e);if(0===n)return\"0\";if(n===1/0)return String(e);const o=Math.floor(Math.log(n)/Math.log(10)),r=e/Math.pow(10,o);return u(r,t-1)+\"e\"+o}(e,t);return Number(n)},a=e=>\"object\"==typeof e&&(e instanceof String||e instanceof Number||e instanceof BigInt||e instanceof Boolean||e instanceof Symbol),s=function(e){const t=\"string\"==typeof e||\"number\"==typeof e||\"boolean\"==typeof e||\"bigint\"==typeof e||\"symbol\"==typeof e;return a(e)||t},p=function(e){return e&&(e.getRootNode()instanceof Document||e.getRootNode()instanceof ShadowRoot)},g=()=>{console.log(\"Hello World!\")},h=function(e,t){const n=[...e,...t],o=new Set(n);return Array.from(o)},y=function(e,t){let n={};return e.forEach(e=>n[e]=1),t.filter(e=>{if(1===n[e])return delete n[e],e})},m=function(e){let t=[];return t.push.apply(t,document.querySelectorAll(e)),t},b=function(){let e=[...arguments].filter(e=>e>=0),t=[...arguments].filter(e=>e<=0);return e.length===arguments.length||t.length===arguments.length},N=function(e){return e.split(\",\").map(e=>e.trim().replace(/\\s+/g,\" \")).filter(e=>e.length)},w=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},d=e=>e.reduce((e,t)=>e+t,0),C=e=>d(e)/e.length||0,M=function(e){let t=\"object\"!=typeof e;return t=t||null===e||a(e),t},S=function(e){let t=e;if(M(e))return e;if(Array.isArray(e)){t=[];for(let n of e)t.push(S(n))}else if(e instanceof Date)t=new Date(e.getTime());else if(e instanceof RegExp)t=new RegExp(e.source,e.flags);else if(\"object\"==typeof e){t={};for(let[n,o]of Object.entries(e))t[n]=S(o)}return t};export{h as arrayCombination,N as arrayFromCommaSeparatedList,m as arrayFromQuery,y as arrayIntersection,S as deepClone,g as greet,w as hasOwnProperty,i as isAlphaNumeric,p as isAttachedToDom,t as isChar,n as isDigit,b as isEqualSigns,l as isExactMatch,M as isFundamental,o as isLetter,r as isLower,s as isPrimitive,f as isUpper,e as isUsableNumber,C as mathAvg,d as mathSum,u as roundAtDecimals,c as roundAtDigits};\n//# sourceMappingURL=myLib.js.map\n","import { arrayToSnapCollect } from './functions'\nimport { arrayIntersection, arrayCombination, isUsableNumber } from 'my-lib'\n\nconst yieldingMethods = {\n    // yielding arrays\n\n    /**\n     * Return all kept records in a two dimensional Array,\n     * using the native Object.entries.\n     * @return {Array} entries\n     */\n    entries: function () {\n        return Object.entries(this)\n    },\n    /**\n     * Return the keys of all kept records,\n     * using the native Object.keys.\n     * @return {String[]} keys\n     */\n    keys: function () {\n        return Object.keys(this)\n    },\n    /**\n     * Return the values of all kept records,\n     * using the native Object.values.\n     * @return {Object[]} values\n     */\n    values: function () {\n        return Object.values(this)\n    },\n\n    /**\n     * Return ascending sorted values of all kept records,\n     * @param {Arguments} anonymus - one or more property names to sort on\n     * @return {Object[]} sorted records\n     */\n    sort: function () {\n        const sorted = Object.values(this)\n        const badVariables = [undefined, null]\n        for (let i = arguments.length - 1; i > -1; i--) {\n            const prop = arguments[i]\n            sorted.sort(function (a, b) {\n                if (isUsableNumber(a[prop], b[prop])) {\n                    return a[prop] - b[prop]\n                }\n                if (badVariables.includes(a[prop])) {\n                    return sorted.length\n                }\n                if (badVariables.includes(b[prop])) {\n                    return 0 - sorted.length\n                }\n                if (a[prop].toString && b[prop].toString) {\n                    let valueA = a[prop].toString()\n                    let valueB = b[prop].toString()\n                    return valueA.localeCompare(valueB)\n                }\n\n                return\n            })\n        }\n        return sorted\n    },\n\n    /**\n     * Find records satisfing all conditions,\n     * using a JSON.stringify comparison.\n     * @param {Object} conditions - one or more conditions\n     * @return {Object[]} subset of records\n     */\n    where: function (conditions) {\n        let subset = Object.values(this)\n        const compareKeys = Object.keys(conditions)\n        compareKeys.forEach((key) => {\n            subset = subset.filter(\n                (subsetItem) =>\n                    JSON.stringify(subsetItem[key]) ===\n                    JSON.stringify(conditions[key]),\n            )\n        })\n        return subset\n    },\n\n    /**\n     * Find all records from both arrays by identifier,\n     * with deduplication.\n     * @param {Object[] || snapCollect} foreignItem\n     * @return {Object[]} common values, deduplicated\n     */\n    combination: function (foreignItem) {\n        if (Array.isArray(foreignItem)) {\n            foreignItem = arrayToSnapCollect.call(this, foreignItem)\n        }\n        const commonKeys = arrayCombination(this.keys(), foreignItem.keys())\n        const commons = commonKeys.map(\n            (key) => this.get(key) || foreignItem.get(key),\n        )\n        return commons\n    },\n\n    /**\n     * Find records appearing in both own collection and in foreign array,\n     * by comparing their identifier,\n     * with deduplication.\n     * @param {Object[] || snapCollect} foreignItem\n     * @return {Object[]} mutual values, deduplicated\n     */\n    intersection: function (foreignItem) {\n        if (Array.isArray(foreignItem)) {\n            foreignItem = arrayToSnapCollect.call(this, foreignItem)\n        }\n        const mutualKeys = arrayIntersection(this.keys(), foreignItem.keys())\n        const mutuals = mutualKeys.map((key) => this.get(key))\n        return mutuals\n    },\n}\n\nexport { yieldingMethods }\n","import { methods } from './core'\nimport { getMainMethods } from './maintenance'\nimport { yieldingMethods } from './yielding'\n\n/**\n * Contruct a SnapCollect object.\n * The identifier is passed form the main function.\n * @private\n * @param {String} identifier\n * @return {Object} the prototype\n */\nconst init = function SnapCollect(identifier) {\n    // determine key to store the held objects\n    const accept = Boolean(identifier)\n    const errMsg = 'snapCollect: identifier must evaluate to true'\n    if (!accept) throw errMsg\n\n    // set characteristic SnapCollect properties\n    methods.identifier = identifier\n    methods.name = 'SnapCollect'\n\n    // append methods object\n    Object.assign(methods, getMainMethods(identifier), yieldingMethods)\n\n    return methods\n}\n\n/**\n * Create a new empty SnapCollect object.\n * The identifier is the unique key used to identify the objects.\n * @param {String} identifier\n * @return {SnapCollect}\n */\nconst snapCollect = function (identifier) {\n    const methods = init(identifier)\n    return Object.create(methods)\n}\n\nexport default snapCollect\n","import { conditionalDeleting, arrayToSnapCollect } from './functions'\n\nconst getMainMethods = function (identifier) {\n    const methods = {\n        // maintenance functions\n\n        /**\n         * Place (or replace) one or more record,\n         * get the key for the record from the field specified by the identifier.\n         * @param {Arguments} anonymus - one or more records\n         * @return {Object[]} all current data\n         */\n        add: function () {\n            const dataList = Array.from(arguments)\n            dataList.forEach((data) => this.set(data[identifier], data))\n            return Object.values(this)\n        },\n        /**\n         * Delete all data and return to initial state.\n         */\n        clear: function () {\n            const keys = Object.keys(this)\n            for (let key of keys) {\n                this.delete(key)\n            }\n        },\n        /**\n         * Confine collection to intersection with array.\n         * @param {Object[] || SnapCollect} foreignItem - other similar data\n         * @return {Object[]} all current data\n         */\n        cross: function (foreignItem) {\n            if (Array.isArray(foreignItem)) {\n                foreignItem = arrayToSnapCollect.call(this, foreignItem)\n            }\n            const foreignKeys = foreignItem.keys()\n            const keys = Object.keys(this)\n            for (let key of keys) {\n                if (!foreignKeys.includes(key)) {\n                    this.delete(key)\n                }\n            }\n            return Object.values(this)\n        },\n        /**\n         * Delete data satisfing all conditions,\n         * using a JSON.stringify comparison.\n         * @param {Object} conditions - one or more conditions\n         * @return {Object[]} all current data\n         */\n        drop: function (conditions) {\n            conditionalDeleting.call(this, conditions, true)\n            return Object.values(this)\n        },\n        /**\n         * Confine collection to the data satisfing all conditions,\n         * using a JSON.stringify comparison.\n         * @param {Object} conditions - one or more conditions\n         * @return {Object[]} all current data\n         */\n        hold: function (conditions) {\n            conditionalDeleting.call(this, conditions, false)\n            return Object.values(this)\n        },\n        /**\n         * Place an unkown record or remove a known record.\n         * @param {Object} data - one unit\n         * @return {Object[]} all current data\n         */\n        toggle: function (data) {\n            const key = data[identifier]\n            if (this.has(key)) {\n                this.delete(key)\n            } else {\n                this.set(key, data)\n            }\n            return Object.values(this)\n        },\n    }\n\n    return methods\n}\n\nexport { getMainMethods }\n"],"names":["keying","value","toString","arrayToSnapCollect","foreignArray","foreignCollection","Object","create","getPrototypeOf","this","add","conditionalDeleting","conditions","isAction","conditionsEntries","entries","values","identifier","collection","satisfing","forEach","condition","JSON","stringify","delete","methods","key","get","has","prototype","hasOwnProperty","call","length","keys","set","data","e","Boolean","arguments","Array","from","t","Number","isFinite","yieldingMethods","sort","sorted","badVariables","undefined","i","prop","a","b","isUsableNumber","includes","valueA","valueB","localeCompare","where","subset","filter","subsetItem","combination","foreignItem","isArray","n","o","Set","arrayCombination","map","intersection","arrayIntersection","init","name","assign","dataList","clear","cross","foreignKeys","drop","hold","toggle","getMainMethods"],"mappings":"AAAA,MAAMA,EAOI,SAAUC,GACZ,OAAOA,GAASA,EAAMC,UARxBF,EAiBI,SAAUC,GACZ,OAAOA,EAAMC,YAWfC,EAAqB,SAAUC,GACjC,MAAMC,EAAoBC,OAAOC,OAAOD,OAAOE,eAAeC,OAE9D,OADAJ,EAAkBK,OAAON,GAClBC,GAoBLM,EAAsB,SAAUC,EAAYC,GAC9C,MAAMC,EAAoBR,OAAOS,QAAQH,GACnCI,EAASV,OAAOU,OAAOP,MACvBQ,GAdsBC,EAcKT,KAb1BH,OAAOE,eAAeU,GAAYD,YADvB,IAAUC,EAe5B,IAAK,IAAIjB,KAASe,EAAQ,CACtB,IAAIG,GAAY,EAChBL,EAAkBM,QAASC,IACvBF,EACIA,GACAG,KAAKC,UAAUtB,EAAMoB,EAAU,OAC3BC,KAAKC,UAAUF,EAAU,MAEjCF,IAAcN,GAAUJ,KAAKe,OAAOvB,EAAMgB,MC9DhDQ,EAAU,CAOZD,OAAQ,SAAUE,GACT1B,EAAY0B,WACVjB,KAAKT,EAAY0B,KAO5BC,IAAK,SAAUD,GACX,GAAK1B,EAAY0B,GACjB,OAAOjB,KAAKT,EAAY0B,KAO5BE,IAAK,SAAUF,GACX,GAAK1B,EAAY0B,GACjB,OAAOpB,OAAOuB,UAAUC,eAAeC,KAAKtB,KAAMT,EAAY0B,KAMlEM,aACI,OAAO1B,OAAO2B,KAAKxB,MAAMuB,QAO7BE,IAAK,SAAUR,EAAKS,GACXnC,EAAY0B,KACjBjB,KAAKT,EAAY0B,IAAQS,KC7C3BC,EAAE,WAAW,IAAIA,EAAEC,QAAQC,UAAUN,QAAQ,OAAOO,MAAMC,KAAKF,WAAWlB,QAAQqB,IAAIL,EAAEA,GAAG,iBAAiBK,GAAGC,OAAOC,SAASF,KAAKL,GCGpIQ,EAAkB,CAQpB7B,QAAS,WACL,OAAOT,OAAOS,QAAQN,OAO1BwB,KAAM,WACF,OAAO3B,OAAO2B,KAAKxB,OAOvBO,OAAQ,WACJ,OAAOV,OAAOU,OAAOP,OAQzBoC,KAAM,WACF,MAAMC,EAASxC,OAAOU,OAAOP,MACvBsC,EAAe,MAACC,EAAW,MACjC,IAAK,IAAIC,EAAIX,UAAUN,OAAS,EAAGiB,GAAK,EAAGA,IAAK,CAC5C,MAAMC,EAAOZ,UAAUW,GACvBH,EAAOD,MAAK,SAAUM,EAAGC,GACrB,GAAIC,EAAeF,EAAED,GAAOE,EAAEF,IAC1B,OAAOC,EAAED,GAAQE,EAAEF,GAEvB,GAAIH,EAAaO,SAASH,EAAED,IACxB,OAAOJ,EAAOd,OAElB,GAAIe,EAAaO,SAASF,EAAEF,IACxB,OAAO,EAAIJ,EAAOd,OAEtB,GAAImB,EAAED,GAAMhD,UAAYkD,EAAEF,GAAMhD,SAAU,CACtC,IAAIqD,EAASJ,EAAED,GAAMhD,WACjBsD,EAASJ,EAAEF,GAAMhD,WACrB,OAAOqD,EAAOE,cAAcD,OAMxC,OAAOV,GASXY,MAAO,SAAU9C,GACb,IAAI+C,EAASrD,OAAOU,OAAOP,MAS3B,OARoBH,OAAO2B,KAAKrB,GACpBQ,QAASM,IACjBiC,EAASA,EAAOC,OACXC,GACGvC,KAAKC,UAAUsC,EAAWnC,MAC1BJ,KAAKC,UAAUX,EAAWc,OAG/BiC,GASXG,YAAa,SAAUC,GACfxB,MAAMyB,QAAQD,KACdA,EAAc5D,EAAmB4B,KAAKtB,KAAMsD,IAMhD,ODhG4sC,SAAS3B,EAAEK,GAAG,MAAMwB,EAAE,IAAI7B,KAAKK,GAAGyB,EAAE,IAAIC,IAAIF,GAAG,OAAO1B,MAAMC,KAAK0B,GC4F1vCE,CAAiB3D,KAAKwB,OAAQ8B,EAAY9B,QAClCoC,IACtB3C,GAAQjB,KAAKkB,IAAID,IAAQqC,EAAYpC,IAAID,KAYlD4C,aAAc,SAAUP,GAChBxB,MAAMyB,QAAQD,KACdA,EAAc5D,EAAmB4B,KAAKtB,KAAMsD,IAIhD,ODhHmxC,SAAS3B,EAAEK,GAAG,IAAIwB,EAAE,GAAG,OAAO7B,EAAEhB,QAAQgB,GAAG6B,EAAE7B,GAAG,GAAGK,EAAEmB,OAAOxB,IAAI,GAAG,IAAI6B,EAAE7B,GAAG,cAAc6B,EAAE7B,GAAGA,IC8G/1CmC,CAAkB9D,KAAKwB,OAAQ8B,EAAY9B,QACnCoC,IAAK3C,GAAQjB,KAAKkB,IAAID,MCpGnD8C,EAAO,SAAqBvD,GAI9B,IAFeoB,QAAQpB,GAEV,KADE,gDAUf,OANAQ,EAAQR,WAAaA,EACrBQ,EAAQgD,KAAO,cAGfnE,OAAOoE,OAAOjD,ECpBK,SAAUR,GA8E7B,MA7EgB,CASZP,IAAK,WACD,MAAMiE,EAAWpC,MAAMC,KAAKF,WAE5B,OADAqC,EAASvD,QAASe,GAAS1B,KAAKyB,IAAIC,EAAKlB,GAAakB,IAC/C7B,OAAOU,OAAOP,OAKzBmE,MAAO,WACH,MAAM3C,EAAO3B,OAAO2B,KAAKxB,MACzB,IAAK,IAAIiB,KAAOO,EACZxB,KAAKe,OAAOE,IAQpBmD,MAAO,SAAUd,GACTxB,MAAMyB,QAAQD,KACdA,EAAc5D,EAAmB4B,KAAKtB,KAAMsD,IAEhD,MAAMe,EAAcf,EAAY9B,OAC1BA,EAAO3B,OAAO2B,KAAKxB,MACzB,IAAK,IAAIiB,KAAOO,EACP6C,EAAYxB,SAAS5B,IACtBjB,KAAKe,OAAOE,GAGpB,OAAOpB,OAAOU,OAAOP,OAQzBsE,KAAM,SAAUnE,GAEZ,OADAD,EAAoBoB,KAAKtB,KAAMG,GAAY,GACpCN,OAAOU,OAAOP,OAQzBuE,KAAM,SAAUpE,GAEZ,OADAD,EAAoBoB,KAAKtB,KAAMG,GAAY,GACpCN,OAAOU,OAAOP,OAOzBwE,OAAQ,SAAU9C,GACd,MAAMT,EAAMS,EAAKlB,GAMjB,OALIR,KAAKmB,IAAIF,GACTjB,KAAKe,OAAOE,GAEZjB,KAAKyB,IAAIR,EAAKS,GAEX7B,OAAOU,OAAOP,QDtDNyE,CAAejE,GAAa2B,GAE5CnB,kBASS,SAAUR,GAC1B,MAAMQ,EAAU+C,EAAKvD,GACrB,OAAOX,OAAOC,OAAOkB"}