{"version":3,"file":"snapCollect.js","sources":["../src/functions.js","../src/core.js","../src/yielding.js","../node_modules/my-lib/module/myLib.js","../src/index.js","../src/maintenance.js"],"sourcesContent":["const keying = {\n    /**\n     * Check value applicable as key\n     * @private\n     * @param {Any} value\n     * @return {Boolean} useablity\n     */\n    test: function (value) {\n        return value && value.toString\n    },\n\n    /**\n     * Compose a key\n     * @private\n     * @param {Any} value - to convert\n     * @return {String} useable key\n     */\n    make: function (value) {\n        return value.toString()\n    },\n}\n\n/**\n * Convert an array to a likewise initialised SnapCollect object\n * @private\n * @this {SnapCollect}\n * @param {Object[]} foreignArray - to convert\n * @return {Object} keyed object\n */\nconst arrayToSnapCollect = function (foreignArray) {\n    const foreignCollection = Object.create(Object.getPrototypeOf(this))\n    foreignCollection.add(...foreignArray)\n    return foreignCollection\n}\n\nexport { keying, arrayToSnapCollect }\n","import { keying } from './functions'\n\nconst methods = {\n    // core functions\n\n    /**\n     * Delete the data kept with a key, and the key itself.\n     * @param {String} key\n     */\n    delete: function (key) {\n        if (!keying.test(key)) return\n        delete this[keying.make(key)]\n    },\n    /**\n     * Get the data kept with a key.\n     * @param {String} key\n     * @return {Object} the data\n     */\n    get: function (key) {\n        if (!keying.test(key)) return\n        return this[keying.make(key)]\n    },\n    /**\n     * Examine the existance of a key.\n     * @param {String} key\n     * @return {Boolean}\n     */\n    has: function (key) {\n        if (!keying.test(key)) return\n        return Object.prototype.hasOwnProperty.call(this, keying.make(key))\n    },\n    /**\n     * Count the number of records kept.\n     * @return {Number}\n     */\n    get length() {\n        return Object.keys(this).length\n    },\n    /**\n     * Place (or replace) a record under a certain key.\n     * @param {String} key\n     * @param {Object} data\n     */\n    set: function (key, data) {\n        if (!keying.test(key)) return\n        this[keying.make(key)] = data\n    },\n}\n\nexport { methods }\n","import { arrayToSnapCollect } from './functions'\nimport { arrayIntersection, arrayCombination } from 'my-lib'\n\nconst yieldingMethods = {\n    // yielding arrays\n\n    /**\n     * Return all kept records in a two dimensional Array,\n     * using the native Object.entries.\n     * @return {Array} entries\n     */\n    entries: function () {\n        return Object.entries(this)\n    },\n    /**\n     * Return the keys of all kept records,\n     * using the native Object.keys.\n     * @return {String[]} keys\n     */\n    keys: function () {\n        return Object.keys(this)\n    },\n    /**\n     * Return the values of all kept records,\n     * using the native Object.values.\n     * @return {Object[]} values\n     */\n    values: function () {\n        return Object.values(this)\n    },\n\n    /**\n     * Find records satisfing a condition,\n     * using a JSON.stringify comparison.\n     * @param {Object} conditions - one or more conditions\n     * @return {Object[]} provided\n     */\n    where: function (conditions) {\n        let subset = Object.values(this)\n        const compareKeys = Object.keys(conditions)\n        compareKeys.forEach((key) => {\n            subset = subset.filter(\n                (subsetItem) =>\n                    JSON.stringify(subsetItem[key]) ==\n                    JSON.stringify(conditions[key]),\n            )\n        })\n        return subset\n    },\n\n    /**\n     * Find all records from both arrays by identifier,\n     * with deduplication.\n     * @param {Object[] || snapCollect} foreignItem\n     * @return {Object[]} common values, deduplicated\n     */\n    combination: function (foreignItem) {\n        if (Array.isArray(foreignItem)) {\n            foreignItem = arrayToSnapCollect.call(this, foreignItem)\n        }\n        const commonKeys = arrayCombination(this.keys(), foreignItem.keys())\n        const commons = commonKeys.map(\n            (key) => this.get(key) || foreignItem.get(key),\n        )\n        return commons\n    },\n\n    /**\n     * Find records appearing in both own collection and in foreign array,\n     * by comparing their identifier,\n     * with deduplication.\n     * @param {Object[] || snapCollect} foreignItem\n     * @return {Object[]} mutual values, deduplicated\n     */\n    intersection: function (foreignItem) {\n        if (Array.isArray(foreignItem)) {\n            foreignItem = arrayToSnapCollect.call(this, foreignItem)\n        }\n        const mutualKeys = arrayIntersection(this.keys(), foreignItem.keys())\n        const mutuals = mutualKeys.map((key) => this.get(key))\n        return mutuals\n    },\n}\n\nexport { yieldingMethods }\n","const e=function(){let e=Boolean(arguments.length);return Array.from(arguments).forEach(t=>{e=e&&\"number\"==typeof t&&Number.isFinite(t)}),e},t=e=>Boolean(e&&\"string\"==typeof e&&1===e.length),n=e=>t(e)&&Boolean(e.match(/[0-9]/)),o=e=>t(e)&&e.toLowerCase()!==e.toUpperCase(),r=e=>t(e)&&e===e.toLowerCase()&&e!==e.toUpperCase(),f=e=>t(e)&&e===e.toUpperCase()&&e!==e.toLowerCase(),i=e=>e&&e.split&&!e.split(\"\").some(e=>!(o(e)||n(e))),l=(e,t)=>{const n=e.match(t);return n&&n[0]===e},u=function(e,t){return e<\"1e-\"+t&&e>\"-1e-\"+t?0:Number(Math.round(e+\"e\"+t)+\"e-\"+t)},c=function(e,t){const n=function(e,t){if(isNaN(e)||!Number.isInteger(t)||t<1)return\"NaN\";const n=Math.abs(e);if(0===n)return\"0\";if(n===1/0)return String(e);const o=Math.floor(Math.log(n)/Math.log(10)),r=e/Math.pow(10,o);return u(r,t-1)+\"e\"+o}(e,t);return Number(n)},a=e=>\"object\"==typeof e&&(e instanceof String||e instanceof Number||e instanceof BigInt||e instanceof Boolean||e instanceof Symbol),s=function(e){const t=\"string\"==typeof e||\"number\"==typeof e||\"boolean\"==typeof e||\"bigint\"==typeof e||\"symbol\"==typeof e;return a(e)||t},p=function(e){return e&&(e.getRootNode()instanceof Document||e.getRootNode()instanceof ShadowRoot)},g=()=>{console.log(\"Hello World!\")},h=function(e,t){const n=[...e,...t],o=new Set(n);return Array.from(o)},y=function(e,t){let n={};return e.forEach(e=>n[e]=1),t.filter(e=>{if(1===n[e])return delete n[e],e})},m=function(e){let t=[];return t.push.apply(t,document.querySelectorAll(e)),t},b=function(){let e=[...arguments].filter(e=>e>=0),t=[...arguments].filter(e=>e<=0);return e.length===arguments.length||t.length===arguments.length},N=function(e){return e.split(\",\").map(e=>e.trim().replace(/\\s+/g,\" \")).filter(e=>e.length)},w=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},d=e=>e.reduce((e,t)=>e+t,0),C=e=>d(e)/e.length||0,M=function(e){let t=\"object\"!=typeof e;return t=t||null===e||a(e),t},S=function(e){let t=e;if(M(e))return e;if(Array.isArray(e)){t=[];for(let n of e)t.push(S(n))}else if(e instanceof Date)t=new Date(e.getTime());else if(e instanceof RegExp)t=new RegExp(e.source,e.flags);else if(\"object\"==typeof e){t={};for(let[n,o]of Object.entries(e))t[n]=S(o)}return t};export{h as arrayCombination,N as arrayFromCommaSeparatedList,m as arrayFromQuery,y as arrayIntersection,S as deepClone,g as greet,w as hasOwnProperty,i as isAlphaNumeric,p as isAttachedToDom,t as isChar,n as isDigit,b as isEqualSigns,l as isExactMatch,M as isFundamental,o as isLetter,r as isLower,s as isPrimitive,f as isUpper,e as isUsableNumber,C as mathAvg,d as mathSum,u as roundAtDecimals,c as roundAtDigits};\n//# sourceMappingURL=myLib.js.map\n","import { methods } from './core'\nimport { getMainMethods } from './maintenance'\nimport { yieldingMethods } from './yielding'\n\n/**\n * Contruct a SnapCollect object.\n * The identifier is passed form the main function.\n * @private\n * @param {String} identifier\n * @return {Object} the prototype\n */\nconst init = function SnapCollect(identifier) {\n    // determine key to store the held objects\n    const accept = Boolean(identifier)\n    const errMsg = 'snapCollect: identifier must evaluate to true'\n    if (!accept) throw errMsg\n\n    // set characteristic SnapCollect properties\n    methods.identifier = identifier\n    methods.name = 'SnapCollect'\n\n    // append methods object\n    Object.assign(methods, getMainMethods(identifier), yieldingMethods)\n\n    return methods\n}\n\n/**\n * Create a new empty SnapCollect object.\n * The identifier is the unique key used to identify the objects.\n * @param {String} identifier\n * @return {SnapCollect}\n */\nconst snapCollect = function (identifier) {\n    const methods = init(identifier)\n    return Object.create(methods)\n}\n\nexport default snapCollect\n","const getMainMethods = function (identifier) {\n    const methods = {\n        // maintenance functions\n\n        /**\n         * Place (or replace) one or more record,\n         * get the key for the record from the field specified by the identifier.\n         * @param {Arguments} anonymus - one or more records\n         */\n        add: function () {\n            const dataList = Array.from(arguments)\n            dataList.forEach((data) => this.set(data[identifier], data))\n        },\n        /**\n         * Delete all data and return to initial state.\n         */\n        clear: function () {\n            const keys = Object.keys(this)\n            for (let key of keys) {\n                this.delete(key)\n            }\n        },\n        /**\n         * Place an unkown record or remove a known record.\n         * @param {Object} data\n         */\n        toggle: function (data) {\n            const key = data[identifier]\n            if (this.has(key)) {\n                this.delete(key)\n            } else {\n                this.set(key, data)\n            }\n        },\n    }\n\n    return methods\n}\n\nexport { getMainMethods }\n"],"names":["keying","value","toString","arrayToSnapCollect","foreignArray","foreignCollection","Object","create","getPrototypeOf","this","add","methods","delete","key","get","has","prototype","hasOwnProperty","call","length","keys","set","data","yieldingMethods","entries","values","where","conditions","subset","forEach","filter","subsetItem","JSON","stringify","combination","foreignItem","Array","isArray","e","t","n","o","Set","from","arrayCombination","map","intersection","arrayIntersection","init","identifier","Boolean","name","assign","dataList","arguments","clear","toggle","getMainMethods"],"mappings":"AAAA,MAAMA,EAOI,SAAUC,GACZ,OAAOA,GAASA,EAAMC,UARxBF,EAiBI,SAAUC,GACZ,OAAOA,EAAMC,YAWfC,EAAqB,SAAUC,GACjC,MAAMC,EAAoBC,OAAOC,OAAOD,OAAOE,eAAeC,OAE9D,OADAJ,EAAkBK,OAAON,GAClBC,GC9BLM,EAAU,CAOZC,OAAQ,SAAUC,GACTb,EAAYa,WACVJ,KAAKT,EAAYa,KAO5BC,IAAK,SAAUD,GACX,GAAKb,EAAYa,GACjB,OAAOJ,KAAKT,EAAYa,KAO5BE,IAAK,SAAUF,GACX,GAAKb,EAAYa,GACjB,OAAOP,OAAOU,UAAUC,eAAeC,KAAKT,KAAMT,EAAYa,KAMlEM,aACI,OAAOb,OAAOc,KAAKX,MAAMU,QAO7BE,IAAK,SAAUR,EAAKS,GACXtB,EAAYa,KACjBJ,KAAKT,EAAYa,IAAQS,KC1C3BC,EAAkB,CAQpBC,QAAS,WACL,OAAOlB,OAAOkB,QAAQf,OAO1BW,KAAM,WACF,OAAOd,OAAOc,KAAKX,OAOvBgB,OAAQ,WACJ,OAAOnB,OAAOmB,OAAOhB,OASzBiB,MAAO,SAAUC,GACb,IAAIC,EAAStB,OAAOmB,OAAOhB,MAS3B,OARoBH,OAAOc,KAAKO,GACpBE,QAAShB,IACjBe,EAASA,EAAOE,OACXC,GACGC,KAAKC,UAAUF,EAAWlB,KAC1BmB,KAAKC,UAAUN,EAAWd,OAG/Be,GASXM,YAAa,SAAUC,GACfC,MAAMC,QAAQF,KACdA,EAAchC,EAAmBe,KAAKT,KAAM0B,IAMhD,OChE4sC,SAASG,EAAEC,GAAG,MAAMC,EAAE,IAAIF,KAAKC,GAAGE,EAAE,IAAIC,IAAIF,GAAG,OAAOJ,MAAMO,KAAKF,GD4D1vCG,CAAiBnC,KAAKW,OAAQe,EAAYf,QAClCyB,IACtBhC,GAAQJ,KAAKK,IAAID,IAAQsB,EAAYrB,IAAID,KAYlDiC,aAAc,SAAUX,GAChBC,MAAMC,QAAQF,KACdA,EAAchC,EAAmBe,KAAKT,KAAM0B,IAIhD,OChFmxC,SAASG,EAAEC,GAAG,IAAIC,EAAE,GAAG,OAAOF,EAAET,QAAQS,GAAGE,EAAEF,GAAG,GAAGC,EAAET,OAAOQ,IAAI,GAAG,IAAIE,EAAEF,GAAG,cAAcE,EAAEF,GAAGA,ID8E/1CS,CAAkBtC,KAAKW,OAAQe,EAAYf,QACnCyB,IAAKhC,GAAQJ,KAAKK,IAAID,MEpEnDmC,EAAO,SAAqBC,GAI9B,IAFeC,QAAQD,GAEV,KADE,gDAUf,OANAtC,EAAQsC,WAAaA,EACrBtC,EAAQwC,KAAO,cAGf7C,OAAO8C,OAAOzC,ECtBK,SAAUsC,GAoC7B,MAnCgB,CAQZvC,IAAK,WACD,MAAM2C,EAAWjB,MAAMO,KAAKW,WAC5BD,EAASxB,QAASP,GAASb,KAAKY,IAAIC,EAAK2B,GAAa3B,KAK1DiC,MAAO,WACH,MAAMnC,EAAOd,OAAOc,KAAKX,MACzB,IAAK,IAAII,KAAOO,EACZX,KAAKG,OAAOC,IAOpB2C,OAAQ,SAAUlC,GACd,MAAMT,EAAMS,EAAK2B,GACbxC,KAAKM,IAAIF,GACTJ,KAAKG,OAAOC,GAEZJ,KAAKY,IAAIR,EAAKS,KDTHmC,CAAeR,GAAa1B,GAE5CZ,kBASS,SAAUsC,GAC1B,MAAMtC,EAAUqC,EAAKC,GACrB,OAAO3C,OAAOC,OAAOI"}