{"version":3,"file":"snapCollect.js","sources":["../src/maintenance.js","../src/functions.js","../src/yielding.js","../node_modules/my-lib/module/myLib.js","../src/index.js"],"sourcesContent":["const getMainMethods = function (identifier) {\n    const methods = {\n        // maintenance functions\n\n        /**\n         * Place (or replace) one or more record,\n         * get the key for the record from the field specified by the identifier.\n         * @param {Arguments} anonymus - one or more records\n         */\n        add: function () {\n            const dataList = Array.from(arguments)\n            dataList.forEach((data) => this.set(data[identifier], data))\n        },\n        /**\n         * Delete all data and return to initial state.\n         */\n        clear: function () {\n            const keys = Object.keys(this)\n            for (let key of keys) {\n                delete this[key.toString()]\n            }\n        },\n        /**\n         * Delete the data kept with a key, and the key itself.\n         * @param {String} key\n         */\n        delete: function (key) {\n            delete this[key.toString()]\n        },\n        /**\n         * Get the data kept with a key.\n         * @param {String} key\n         * @return {Object} the data\n         */\n        get: function (key) {\n            return this[key.toString()]\n        },\n        /**\n         * Examine the existance of a key.\n         * @param {String} key\n         * @return {Boolean}\n         */\n        has: function (key) {\n            return Object.prototype.hasOwnProperty.call(this, key.toString())\n        },\n        /**\n         * Count the number of records kept.\n         * @return {Number}\n         */\n        get length() {\n            return Object.keys(this).length\n        },\n        /**\n         * Place (or replace) a record under a certain key.\n         * @param {String} key\n         * @param {Object} data\n         */\n        set: function (key, data) {\n            this[key.toString()] = data\n        },\n        /**\n         * Place an unkown record or remove a known record.\n         * @param {Object} data\n         */\n        toggle: function (data) {\n            const key = data[identifier]\n            if (this.has(key)) {\n                this.delete(key)\n            } else {\n                this.set(key, data)\n            }\n        },\n    }\n\n    return methods\n}\n\nexport { getMainMethods }\n","/**\n * Convert an array to a pseudo SnapCollect object\n * @private\n * @this {SnapCollect}\n * @param {Object[]} foreignArray - to convert\n * @return {Object} keyed object\n */\nconst arrayToPseudoObject = function (foreignArray) {\n    const pseudoObject = Object.create({ identifier: this.identifier })\n    foreignArray.forEach((data) => {\n        pseudoObject[data[this.identifier].toString()] = data\n    })\n    return pseudoObject\n}\n\n/**\n * Find our type of keys in a pseudoObject\n * @private\n * @param {SnapCollect} foreignCollection (pseudo) SnapCollect - to relate with\n * @return {Object[]}\n */\nconst getForeignKeys = function (foreignCollection) {\n    return Object.keys(foreignCollection)\n}\n\nexport { arrayToPseudoObject, getForeignKeys }\n","import { arrayToPseudoObject, getForeignKeys } from './functions'\nimport { arrayIntersection, arrayCombination } from 'my-lib'\n\nconst yieldingMethods = {\n    // yielding arrays\n\n    /**\n     * Return all kept records in a two dimensional Array,\n     * using the native Object.entries.\n     * @return {Array} entries\n     */\n    entries: function () {\n        return Object.entries(this)\n    },\n    /**\n     * Return the keys of all kept records,\n     * using the native Object.keys.\n     * @return {String[]} keys\n     */\n    keys: function () {\n        return Object.keys(this)\n    },\n    /**\n     * Return the values of all kept records,\n     * using the native Object.values.\n     * @return {Object[]} values\n     */\n    values: function () {\n        return Object.values(this)\n    },\n\n    /**\n     * Find records satisfing a condition,\n     * using a JSON.stringify comparison.\n     * @param {Object} conditions - one or more conditions\n     * @return {Object[]} provided\n     */\n    where: function (conditions) {\n        let subset = Object.values(this)\n        const compareKeys = Object.keys(conditions)\n        compareKeys.forEach((key) => {\n            subset = subset.filter(\n                (subsetItem) =>\n                    JSON.stringify(subsetItem[key]) ==\n                    JSON.stringify(conditions[key]),\n            )\n        })\n        return subset\n    },\n\n    /**\n     * Find all records from both arrays by identifier,\n     * with deduplication.\n     * @param {Object[] || snapCollect} foreignItem\n     * @return {Object[]} common values, deduplicated\n     */\n    combination: function (foreignItem) {\n        if (Array.isArray(foreignItem)) {\n            foreignItem = arrayToPseudoObject.call(this, foreignItem)\n        }\n        const foreignKeys = getForeignKeys(foreignItem)\n        const commonKeys = arrayCombination(this.keys(), foreignKeys)\n        const commons = commonKeys.map((common) => {\n            const domestic = this.get(common.toString())\n            const foreign = foreignItem[common]\n            return domestic || foreign\n        })\n        return commons\n    },\n\n    /**\n     * Find records appearing in both own collection and in foreign array,\n     * by comparing their identifier,\n     * with deduplication.\n     * @param {Object[] || snapCollect} foreignItem\n     * @return {Object[]} mutual values, deduplicated\n     */\n    intersection: function (foreignItem) {\n        if (Array.isArray(foreignItem)) {\n            foreignItem = arrayToPseudoObject.call(this, foreignItem)\n        }\n        const foreignKeys = getForeignKeys(foreignItem)\n        const mutualKeys = arrayIntersection(this.keys(), foreignKeys)\n        const mutuals = mutualKeys.map((mutual) => this.get(mutual.toString()))\n        return mutuals\n    },\n}\n\nexport { yieldingMethods }\n","const e=function(){let e=Boolean(arguments.length);return Array.from(arguments).forEach(t=>{e=e&&\"number\"==typeof t&&Number.isFinite(t)}),e},t=e=>Boolean(e&&\"string\"==typeof e&&1===e.length),n=e=>t(e)&&Boolean(e.match(/[0-9]/)),o=e=>t(e)&&e.toLowerCase()!==e.toUpperCase(),r=e=>t(e)&&e===e.toLowerCase()&&e!==e.toUpperCase(),f=e=>t(e)&&e===e.toUpperCase()&&e!==e.toLowerCase(),i=e=>e&&e.split&&!e.split(\"\").some(e=>!(o(e)||n(e))),l=(e,t)=>{const n=e.match(t);return n&&n[0]===e},u=function(e,t){return e<\"1e-\"+t&&e>\"-1e-\"+t?0:Number(Math.round(e+\"e\"+t)+\"e-\"+t)},c=function(e,t){const n=function(e,t){if(isNaN(e)||!Number.isInteger(t)||t<1)return\"NaN\";const n=Math.abs(e);if(0===n)return\"0\";if(n===1/0)return String(e);const o=Math.floor(Math.log(n)/Math.log(10)),r=e/Math.pow(10,o);return u(r,t-1)+\"e\"+o}(e,t);return Number(n)},a=e=>\"object\"==typeof e&&(e instanceof String||e instanceof Number||e instanceof BigInt||e instanceof Boolean||e instanceof Symbol),s=function(e){const t=\"string\"==typeof e||\"number\"==typeof e||\"boolean\"==typeof e||\"bigint\"==typeof e||\"symbol\"==typeof e;return a(e)||t},p=function(e){return e&&(e.getRootNode()instanceof Document||e.getRootNode()instanceof ShadowRoot)},g=()=>{console.log(\"Hello World!\")},h=function(e,t){const n=[...e,...t],o=new Set(n);return Array.from(o)},y=function(e,t){let n={};return e.forEach(e=>n[e]=1),t.filter(e=>{if(1===n[e])return delete n[e],e})},m=function(e){let t=[];return t.push.apply(t,document.querySelectorAll(e)),t},b=function(){let e=[...arguments].filter(e=>e>=0),t=[...arguments].filter(e=>e<=0);return e.length===arguments.length||t.length===arguments.length},N=function(e){return e.split(\",\").map(e=>e.trim().replace(/\\s+/g,\" \")).filter(e=>e.length)},w=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},d=e=>e.reduce((e,t)=>e+t,0),C=e=>d(e)/e.length||0,M=function(e){let t=\"object\"!=typeof e;return t=t||null===e||a(e),t},S=function(e){let t=e;if(M(e))return e;if(Array.isArray(e)){t=[];for(let n of e)t.push(S(n))}else if(e instanceof Date)t=new Date(e.getTime());else if(e instanceof RegExp)t=new RegExp(e.source,e.flags);else if(\"object\"==typeof e){t={};for(let[n,o]of Object.entries(e))t[n]=S(o)}return t};export{h as arrayCombination,N as arrayFromCommaSeparatedList,m as arrayFromQuery,y as arrayIntersection,S as deepClone,g as greet,w as hasOwnProperty,i as isAlphaNumeric,p as isAttachedToDom,t as isChar,n as isDigit,b as isEqualSigns,l as isExactMatch,M as isFundamental,o as isLetter,r as isLower,s as isPrimitive,f as isUpper,e as isUsableNumber,C as mathAvg,d as mathSum,u as roundAtDecimals,c as roundAtDigits};\n//# sourceMappingURL=myLib.js.map\n","import { getMainMethods } from './maintenance'\nimport { yieldingMethods } from './yielding'\n\n/**\n * Contruct a SnapCollect object.\n * The identifier is passed form the main function.\n * @private\n * @param {String} identifier\n * @return {Object} the prototype\n */\nconst init = function SnapCollect(identifier) {\n    // determine key to store the held objects\n    const accept = Boolean(identifier)\n    const errMsg = 'snapCollect: identifier must evaluate to true'\n    if (!accept) throw errMsg\n\n    // build methods object\n    const methods = getMainMethods(identifier)\n    Object.assign(methods, yieldingMethods)\n\n    // set characteristic SnapCollect properties\n    methods.identifier = identifier\n    methods.name = 'SnapCollect'\n\n    return methods\n}\n\n/**\n * Create a new empty SnapCollect object.\n * The identifier is the unique key used to identify the objects.\n * @param {String} identifier\n * @return {SnapCollect}\n */\nconst snapCollect = function (identifier) {\n    const methods = init(identifier)\n    return Object.create(methods)\n}\n\nexport default snapCollect\n"],"names":["arrayToPseudoObject","foreignArray","pseudoObject","Object","create","identifier","this","forEach","data","toString","getForeignKeys","foreignCollection","keys","yieldingMethods","entries","values","where","conditions","subset","key","filter","subsetItem","JSON","stringify","combination","foreignItem","Array","isArray","call","foreignKeys","e","t","n","o","Set","from","arrayCombination","map","common","domestic","get","foreign","intersection","arrayIntersection","mutual","init","Boolean","methods","add","dataList","arguments","set","clear","delete","has","prototype","hasOwnProperty","length","toggle","getMainMethods","assign","name"],"mappings":"4OAAA,MCOMA,EAAsB,SAAUC,GAClC,MAAMC,EAAeC,OAAOC,OAAO,CAAEC,WAAYC,KAAKD,aAItD,OAHAJ,EAAaM,QAASC,IAClBN,EAAaM,EAAKF,KAAKD,YAAYI,YAAcD,IAE9CN,GASLQ,EAAiB,SAAUC,GAC7B,OAAOR,OAAOS,KAAKD,ICnBjBE,EAAkB,CAQpBC,QAAS,WACL,OAAOX,OAAOW,QAAQR,OAO1BM,KAAM,WACF,OAAOT,OAAOS,KAAKN,OAOvBS,OAAQ,WACJ,OAAOZ,OAAOY,OAAOT,OASzBU,MAAO,SAAUC,GACb,IAAIC,EAASf,OAAOY,OAAOT,MAS3B,OARoBH,OAAOS,KAAKK,GACpBV,QAASY,IACjBD,EAASA,EAAOE,OACXC,GACGC,KAAKC,UAAUF,EAAWF,KAC1BG,KAAKC,UAAUN,EAAWE,OAG/BD,GASXM,YAAa,SAAUC,GACfC,MAAMC,QAAQF,KACdA,EAAczB,EAAoB4B,KAAKtB,KAAMmB,IAEjD,MAAMI,EAAcnB,EAAee,GAOnC,OCnE4sC,SAASK,EAAEC,GAAG,MAAMC,EAAE,IAAIF,KAAKC,GAAGE,EAAE,IAAIC,IAAIF,GAAG,OAAON,MAAMS,KAAKF,GD6D1vCG,CAAiB9B,KAAKM,OAAQiB,GACtBQ,IAAKC,IAC5B,MAAMC,EAAWjC,KAAKkC,IAAIF,EAAO7B,YAC3BgC,EAAUhB,EAAYa,GAC5B,OAAOC,GAAYE,KAY3BC,aAAc,SAAUjB,GAChBC,MAAMC,QAAQF,KACdA,EAAczB,EAAoB4B,KAAKtB,KAAMmB,IAEjD,MAAMI,EAAcnB,EAAee,GAGnC,OCpFmxC,SAASK,EAAEC,GAAG,IAAIC,EAAE,GAAG,OAAOF,EAAEvB,QAAQuB,GAAGE,EAAEF,GAAG,GAAGC,EAAEX,OAAOU,IAAI,GAAG,IAAIE,EAAEF,GAAG,cAAcE,EAAEF,GAAGA,IDkF/1Ca,CAAkBrC,KAAKM,OAAQiB,GACvBQ,IAAKO,GAAWtC,KAAKkC,IAAII,EAAOnC,eEzE7DoC,EAAO,SAAqBxC,GAI9B,IAFeyC,QAAQzC,GAEV,KADE,gDAIf,MAAM0C,EJjBa,SAAU1C,GA0E7B,MAzEgB,CAQZ2C,IAAK,WACD,MAAMC,EAAWvB,MAAMS,KAAKe,WAC5BD,EAAS1C,QAASC,GAASF,KAAK6C,IAAI3C,EAAKH,GAAaG,KAK1D4C,MAAO,WACH,MAAMxC,EAAOT,OAAOS,KAAKN,MACzB,IAAK,IAAIa,KAAOP,SACLN,KAAKa,EAAIV,aAOxB4C,OAAQ,SAAUlC,UACPb,KAAKa,EAAIV,aAOpB+B,IAAK,SAAUrB,GACX,OAAOb,KAAKa,EAAIV,aAOpB6C,IAAK,SAAUnC,GACX,OAAOhB,OAAOoD,UAAUC,eAAe5B,KAAKtB,KAAMa,EAAIV,aAM1DgD,aACI,OAAOtD,OAAOS,KAAKN,MAAMmD,QAO7BN,IAAK,SAAUhC,EAAKX,GAChBF,KAAKa,EAAIV,YAAcD,GAM3BkD,OAAQ,SAAUlD,GACd,MAAMW,EAAMX,EAAKH,GACbC,KAAKgD,IAAInC,GACTb,KAAK+C,OAAOlC,GAEZb,KAAK6C,IAAIhC,EAAKX,KIpDVmD,CAAetD,GAO/B,OANAF,OAAOyD,OAAOb,EAASlC,GAGvBkC,EAAQ1C,WAAaA,EACrB0C,EAAQc,KAAO,cAERd,UASS,SAAU1C,GAC1B,MAAM0C,EAAUF,EAAKxC,GACrB,OAAOF,OAAOC,OAAO2C"}