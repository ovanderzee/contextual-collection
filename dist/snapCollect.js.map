{"version":3,"file":"snapCollect.js","sources":["../src/functions.js","../src/core.js","../src/maintenance.js","../node_modules/my-lib/module/myLib.js","../src/yielding.js","../src/index.js"],"sourcesContent":["const keying = {\n    /**\n     * Check value applicable as key\n     * @private\n     * @param {Any} value\n     * @return {Boolean} useablity\n     */\n    test: function (value) {\n        return value && value.toString\n    },\n\n    /**\n     * Compose a key\n     * @private\n     * @param {Any} value - to convert\n     * @return {String} useable key\n     */\n    make: function (value) {\n        return value.toString()\n    },\n}\n\n/**\n * Set characteristic SnapCollect properties\n * @private\n * @param {Object} collection - the instance\n * @param {String} identifier - instance specific property\n */\nconst addSnapCollectProperties = function (collection, identifier) {\n    Object.defineProperties(collection, {\n        identifier: {\n            value: identifier,\n        },\n        name: {\n            value: 'SnapCollect',\n        },\n    })\n}\n\n/**\n * Convert an array to a likewise initialised SnapCollect object\n * @private\n * @this {SnapCollect}\n * @param {Object[]} foreignArray - to convert\n * @return {Object} keyed object\n */\nconst arrayToSnapCollect = function (foreignArray) {\n    const foreignCollection = Object.create(Object.getPrototypeOf(this))\n    addSnapCollectProperties(foreignCollection, this.identifier)\n    foreignCollection.add(...foreignArray)\n    return foreignCollection\n}\n\n/**\n * Act on data satisfing all conditions,\n * using a JSON.stringify comparison.\n * @private\n * @param {Object} conditions - one or more conditions\n * @param {Boolean} isAction - act on true or act on false\n */\nconst conditionalDeleting = function (conditions, isAction) {\n    const conditionsEntries = Object.entries(conditions)\n    const values = Object.values(this)\n\n    for (let value of values) {\n        let satisfing = true\n        conditionsEntries.forEach((condition) => {\n            satisfing =\n                satisfing &&\n                JSON.stringify(value[condition[0]]) ===\n                    JSON.stringify(condition[1])\n        })\n        if (satisfing === isAction) this.delete(value[this.identifier])\n    }\n}\n\nexport {\n    keying,\n    addSnapCollectProperties,\n    arrayToSnapCollect,\n    conditionalDeleting,\n}\n","import { keying } from './functions'\n\nconst coreMethods = {\n    // core functions\n\n    /**\n     * Delete the data kept with a key, and the key itself.\n     * @param {String} key\n     */\n    delete: function (key) {\n        if (!keying.test(key)) return\n        delete this[keying.make(key)]\n    },\n    /**\n     * Get the data kept with a key.\n     * @param {String} key\n     * @return {Object} the data\n     */\n    get: function (key) {\n        if (!keying.test(key)) return\n        return this[keying.make(key)]\n    },\n    /**\n     * Examine the existance of a key.\n     * @param {String} key\n     * @return {Boolean}\n     */\n    has: function (key) {\n        if (!keying.test(key)) return\n        return Object.prototype.hasOwnProperty.call(this, keying.make(key))\n    },\n    /**\n     * Count the number of records kept.\n     * @return {Number}\n     */\n    get length() {\n        return Object.keys(this).length\n    },\n    /**\n     * Place (or replace) a record under a certain key.\n     * @param {String} key\n     * @param {Object} data\n     */\n    set: function (key, data) {\n        if (!keying.test(key)) return\n        this[keying.make(key)] = data\n    },\n}\n\nexport { coreMethods }\n","import { conditionalDeleting, arrayToSnapCollect } from './functions'\n\nconst maintenanceMethods = {\n    // maintenance functions\n\n    /**\n     * Place (or replace) one or more record,\n     * get the key for the record from the field specified by the this.identifier.\n     * @param {Arguments} anonymus - one or more records\n     * @return {Object[]} all current data\n     */\n    add: function () {\n        const dataList = Array.from(arguments)\n        dataList.forEach((data) => this.set(data[this.identifier], data))\n        return Object.values(this)\n    },\n    /**\n     * Delete all data and return to initial state.\n     */\n    clear: function () {\n        const keys = Object.keys(this)\n        for (let key of keys) {\n            this.delete(key)\n        }\n    },\n    /**\n     * Confine collection to intersection with array.\n     * @param {Object[] || SnapCollect} foreignItem - other similar data\n     * @return {Object[]} all current data\n     */\n    cross: function (foreignItem) {\n        if (Array.isArray(foreignItem)) {\n            foreignItem = arrayToSnapCollect.call(this, foreignItem)\n        }\n        const foreignKeys = foreignItem.keys()\n        const keys = Object.keys(this)\n        for (let key of keys) {\n            if (!foreignKeys.includes(key)) {\n                this.delete(key)\n            }\n        }\n        return Object.values(this)\n    },\n    /**\n     * Delete data satisfing all conditions,\n     * using a JSON.stringify comparison.\n     * @param {Object} conditions - one or more conditions\n     * @return {Object[]} all current data\n     */\n    drop: function (conditions) {\n        conditionalDeleting.call(this, conditions, true)\n        return Object.values(this)\n    },\n    /**\n     * Confine collection to the data satisfing all conditions,\n     * using a JSON.stringify comparison.\n     * @param {Object} conditions - one or more conditions\n     * @return {Object[]} all current data\n     */\n    hold: function (conditions) {\n        conditionalDeleting.call(this, conditions, false)\n        return Object.values(this)\n    },\n    /**\n     * Place an unkown record or remove a known record.\n     * @param {Object} data - one unit\n     * @return {Object[]} all current data\n     */\n    toggle: function (data) {\n        const key = data[this.identifier]\n        if (this.has(key)) {\n            this.delete(key)\n        } else {\n            this.set(key, data)\n        }\n        return Object.values(this)\n    },\n}\n\nexport { maintenanceMethods }\n","const t=function(){let t=Boolean(arguments.length);return Array.from(arguments).forEach(e=>{t=t&&\"number\"==typeof e&&Number.isFinite(e)}),t},e=t=>Boolean(t&&\"string\"==typeof t&&1===t.length),n=t=>e(t)&&Boolean(t.match(/[0-9]/)),r=t=>e(t)&&t.toLowerCase()!==t.toUpperCase(),o=t=>e(t)&&t===t.toLowerCase()&&t!==t.toUpperCase(),i=t=>e(t)&&t===t.toUpperCase()&&t!==t.toLowerCase(),c=t=>t&&t.split&&!t.split(\"\").some(t=>!(r(t)||n(t))),f=(t,e)=>{const n=t.match(e);return n&&n[0]===t},u=function(t,e){return t<\"1e-\"+e&&t>\"-1e-\"+e?0:Number(Math.round(t+\"e\"+e)+\"e-\"+e)},l=function(t,e){const n=function(t,e){if(isNaN(t)||!Number.isInteger(e)||e<1)return\"NaN\";const n=Math.abs(t);if(0===n)return\"0\";if(n===1/0)return String(t);const r=Math.floor(Math.log(n)/Math.log(10)),o=t/Math.pow(10,r);return u(o,e-1)+\"e\"+r}(t,e);return Number(n)},a=t=>\"object\"==typeof t&&(t instanceof String||t instanceof Number||t instanceof BigInt||t instanceof Boolean||t instanceof Symbol),s=function(t){const e=\"string\"==typeof t||\"number\"==typeof t||\"boolean\"==typeof t||\"bigint\"==typeof t||\"symbol\"==typeof t;return a(t)||e},p=function(t){return t&&(t.getRootNode()instanceof Document||t.getRootNode()instanceof ShadowRoot)},g=()=>{console.log(\"Hello World!\")},h=function(t,e){const n=[...t,...e],r=new Set(n);return Array.from(r)},y=function(t,e){let n={};return t.forEach(t=>n[t]=1),e.filter(t=>{if(1===n[t])return delete n[t],t})},b=function(t){let e=[];return e.push.apply(e,document.querySelectorAll(t)),e},m=function(){let t=[...arguments].filter(t=>t>=0),e=[...arguments].filter(t=>t<=0);return t.length===arguments.length||e.length===arguments.length},N=function(t){return t.split(\",\").map(t=>t.trim().replace(/\\s+/g,\" \")).filter(t=>t.length)},j=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},w=t=>t.reduce((t,e)=>t+e,0),S=t=>w(t)/t.length||0,d=function(t){let e=\"object\"!=typeof t;return e=e||null===t||a(t),e},C=function(t){let e=t;if(d(t))return t;if(Array.isArray(t)){e=[];for(let n of t)e.push(C(n))}else if(t instanceof Date)e=new Date(t.getTime());else if(t instanceof RegExp)e=new RegExp(t.source,t.flags);else if(\"object\"==typeof t){e={};for(let[n,r]of Object.entries(t))e[n]=C(r)}return e},M=function(t){try{return JSON.stringify(t)}catch(t){return\"\"}},O=function(t){let e;try{return e=String(t),\"[object Object]\"===e&&(e=M(t)),e}catch(e){return M(t)}},A=function(t){let e;try{return e=t.toString(),\"[object Object]\"===e&&(e=O(t)),e}catch(e){return O(t)}};export{h as arrayCombination,N as arrayFromCommaSeparatedList,b as arrayFromQuery,y as arrayIntersection,C as deepClone,O as forceStringify,g as greet,j as hasOwnProperty,c as isAlphaNumeric,p as isAttachedToDom,e as isChar,n as isDigit,m as isEqualSigns,f as isExactMatch,d as isFundamental,r as isLetter,o as isLower,s as isPrimitive,i as isUpper,t as isUsableNumber,S as mathAvg,w as mathSum,u as roundAtDecimals,l as roundAtDigits,A as stringify};\n//# sourceMappingURL=myLib.js.map\n","import { arrayToSnapCollect } from './functions'\nimport {\n    arrayIntersection,\n    arrayCombination,\n    isUsableNumber,\n    forceStringify,\n} from 'my-lib'\n\nconst yieldingMethods = {\n    // yielding arrays\n\n    /**\n     * Return all kept records in a two dimensional Array,\n     * using the native Object.entries.\n     * @return {Array} entries\n     */\n    entries: function () {\n        return Object.entries(this)\n    },\n    /**\n     * Return the keys of all kept records,\n     * using the native Object.keys.\n     * @return {String[]} keys\n     */\n    keys: function () {\n        return Object.keys(this)\n    },\n    /**\n     * Return the values of all kept records,\n     * using the native Object.values.\n     * @return {Object[]} values\n     */\n    values: function () {\n        return Object.values(this)\n    },\n\n    /**\n     * Return ascending sorted values of all kept records\n     * @param {Arguments} anonymus - one or more property names to sort on, most important property first\n     * @return {Object[]} sorted records\n     */\n    sort: function () {\n        const sorted = Object.values(this)\n        const lacksToString = function (value) {\n            try {\n                return !value.toString\n            } catch (e) {\n                return true\n            }\n        }\n        for (let i = arguments.length - 1; i > -1; i--) {\n            const prop = arguments[i]\n            sorted.sort(function (a, b) {\n                if (isUsableNumber(a[prop], b[prop])) {\n                    return a[prop] - b[prop]\n                }\n                if (lacksToString(a[prop]) && lacksToString(b[prop])) {\n                    const valueA = forceStringify(a[prop])\n                    const valueB = forceStringify(a[prop])\n                    return valueA.localeCompare(valueB)\n                }\n                if (lacksToString(a[prop])) {\n                    return sorted.length\n                }\n                if (lacksToString(b[prop])) {\n                    return 0 - sorted.length\n                }\n                // here, everything has a toString method\n                const valueA = a[prop].toString()\n                const valueB = b[prop].toString()\n                return valueA.localeCompare(valueB)\n            })\n        }\n        return sorted\n    },\n\n    /**\n     * Find records satisfing all conditions,\n     * using a JSON.stringify comparison.\n     * @param {Object} conditions - one or more conditions\n     * @return {Object[]} subset of records\n     */\n    where: function (conditions) {\n        let subset = Object.values(this)\n        const compareKeys = Object.keys(conditions)\n        compareKeys.forEach((key) => {\n            subset = subset.filter(\n                (subsetItem) =>\n                    JSON.stringify(subsetItem[key]) ===\n                    JSON.stringify(conditions[key]),\n            )\n        })\n        return subset\n    },\n\n    /**\n     * Find all records from both arrays by identifier,\n     * with deduplication.\n     * @param {Object[] || snapCollect} foreignItem\n     * @return {Object[]} common values, deduplicated\n     */\n    combination: function (foreignItem) {\n        if (Array.isArray(foreignItem)) {\n            foreignItem = arrayToSnapCollect.call(this, foreignItem)\n        }\n        const commonKeys = arrayCombination(this.keys(), foreignItem.keys())\n        const commons = commonKeys.map(\n            (key) => this.get(key) || foreignItem.get(key),\n        )\n        return commons\n    },\n\n    /**\n     * Find records appearing in both own collection and in foreign array,\n     * by comparing their identifier,\n     * with deduplication.\n     * @param {Object[] || snapCollect} foreignItem\n     * @return {Object[]} mutual values, deduplicated\n     */\n    intersection: function (foreignItem) {\n        if (Array.isArray(foreignItem)) {\n            foreignItem = arrayToSnapCollect.call(this, foreignItem)\n        }\n        const mutualKeys = arrayIntersection(this.keys(), foreignItem.keys())\n        const mutuals = mutualKeys.map((key) => this.get(key))\n        return mutuals\n    },\n}\n\nexport { yieldingMethods }\n","import { addSnapCollectProperties } from './functions'\nimport { coreMethods } from './core'\nimport { maintenanceMethods } from './maintenance'\nimport { yieldingMethods } from './yielding'\n\n/**\n * Construct a SnapCollect object.\n * @private\n * @param {String} identifier\n * @return {Object} the prototype\n */\nconst init = function SnapCollect(identifier) {\n    // determine key to store the held objects\n    const accept = Boolean(identifier)\n    const errMsg = 'snapCollect: identifier must evaluate to true'\n    if (!accept) throw errMsg\n\n    // append coreMethods object\n    Object.assign(coreMethods, maintenanceMethods, yieldingMethods)\n\n    return coreMethods\n}\n\n/**\n * Create a new empty SnapCollect object.\n * @param {String} identifier - unique key identifing the objects.\n * @return {SnapCollect}\n */\nconst snapCollect = function (identifier) {\n    const methods = init(identifier)\n    const collection = Object.create(methods)\n    addSnapCollectProperties(collection, identifier)\n    return collection\n}\n\nexport default snapCollect\n"],"names":["keying","value","toString","addSnapCollectProperties","collection","identifier","Object","defineProperties","name","arrayToSnapCollect","foreignArray","foreignCollection","create","getPrototypeOf","this","add","conditionalDeleting","conditions","isAction","conditionsEntries","entries","values","satisfing","forEach","condition","JSON","stringify","delete","coreMethods","key","get","has","prototype","hasOwnProperty","call","length","keys","set","data","maintenanceMethods","dataList","Array","from","arguments","clear","cross","foreignItem","isArray","foreignKeys","includes","drop","hold","toggle","t","Boolean","e","Number","isFinite","M","O","String","yieldingMethods","sort","sorted","lacksToString","i","prop","a","b","isUsableNumber","valueA","forceStringify","valueB","localeCompare","where","subset","filter","subsetItem","combination","n","r","Set","arrayCombination","map","intersection","arrayIntersection","methods","assign","init"],"mappings":"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"}